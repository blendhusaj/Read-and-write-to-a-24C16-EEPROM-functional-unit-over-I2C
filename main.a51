
;	IN THIS PROJECT, THE RAM AREAS OF 24C16 ARE WRITTEN WITH USER DEFINED DATA.
;	DOT MATRIX DISPLAY OF 4 DIGITS IS USED IN THE PROJECT.

;	4X4 MATRIX KEYBOARD WITH KEYS 0 - 9 AND A - F IS INTERFACED.
;	A BUTTON IS CONNECTED TO PORT PIN WHICH STATES WHETHER READ OR WRITE OPERATION IS TO BE PERFORMED.

;	24C16 HAS 2048 PAGES OF 8 BITS
;	ADDRESSING RANGES FROM 000 TO 7FF

;	ALGORITHM FLOW:
;		THE DOT MATRIX WILL INITIALLY SHOW - - - -
;		WHEN THE USER CLICKS ON ANY BUTTON, THE ALGORITHM STARTS. IT FIRST CHECKS THE STATE OF THE R/W BUTTON AND FOLLOWS THE SUBROUTINE.
;		THE ADDRESS TAKES UP 3 DIGITS OF THE DISPLAY.
;		DURING THE READ OPERATION, THE OPERATION DIGIT CHANGES TO 'R'. DURING WRITE OPERATION, IT CHANGES TO 'W'
;		AFTER THE ADDRESSES ARE INPUT, IF THE R/W BUTTON IS CLOSED, THEN DATA AT THAT LOCATION IS SHOWN.
;		IF WRITE OPERATION, THEN THE DIPLAY CHANGES TO W - 0 0. THE USER HAS TO ENTER THE DATA FOLLOWING WHICH THE WRITE IS PERFORMED.


;####### REGISTERS USED #########

;!!!!!!!!!!!!!! BELOW REGS USED IN ISR !!!!!!!!!!!!!!!!!!!!
;0x30 to 0x33 -> FOR STORING THE VALUES TO BE DISPLAYED. 

;0x37 IS THE 8 BIT COUNTER
;0x39 HAS THE ADDRESS OFFSET OF THE DISPLAY REGISTER

;0x3C STORING R1 POINTER VALUE FOR PRESERVING ISR
;0x3D STORING R2 POINTER VALUE FOR PRESERVING ISR

;0x3E FOR BACKING UP R1 AFTER ISR IS INITIATED
;0x3F FOR BACKING UP R0 AFTER ISR IS INITIATED

;0x38 FOR BACKING UP A
;0x3B IS USED TO BACKUP B REGISTER

;0x39 HAS THE ADDRESS OFFSET OF THE PARTICULAR CHARACTER

;0x20.0 IS USED IN DISPLAY SUBROUTINE. IF CLR THEN STAGE 1 EXECUTED AFTER INTERRUPT IS SERVICES ELSE STAGE 2
;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

;0x20.1 STATES IF A VALID BUTTON WAS CLICKED. IF SET THEN YES.

;R7 IS USED AS A COUNTER

;R3 AND R4 ARE USED IN I2C SUBROUTINE


;####### PORT PINS DEFINED #######
;FOR 4094
DAT EQU P2.0
CLK EQU P2.1
STR EQU P2.2
	
;FOR I2C
SDA EQU P2.3
SCL EQU P2.4

;KEYBOARD/ BUTTONS
RW_BTN EQU P2.5
;P1 IS INTERFACED TO MATRIX KEYBOARD


ORG 0H
	LJMP START
	
	
	

ORG 000BH
	;TIMER 0 OVERFLOW OCCURS HERE
	;THIS ROUTINE IS USED FOR UPDATING THE DISPLAY

	;0x37 IS THE 8 BIT COUNTER
	;0x39 HAS THE ADDRESS OFFSET OF THE PARTICULAR CHARACTER [UNIT 1 DISP]
	

;DISPLAY UNIT 1: 0x30 0x31 0x32
	
	
	CLR TR0
	MOV 0x38, A; BACKUP A
	MOV 0x3B, B; BACKUP B
	
	MOV 0x3E, 0x01; BACKUP R1 POINTER
	MOV 0x3F, 0x00; BACKUP R0 POINTER
	
	
	MOV 0x01, 0x3C; RESTORE R1 POINTER
	MOV 0x00, 0x3D; RESTORE R0 POINTER
	
	;-------------- LOGIC STARTS HERE -------------
	JB 0x20.0, STAGE_2_DISPLAY
	
	
	;---------- STAGE 1 -------------
	REPEAT_CYCLE:
	MOV 0x37, #8
	MOV R1, #0x30
	
	MOV A, @R1
	MOV B, #8
	MUL AB
	MOV 0x39, A

	CLR CLK
	SETB DAT
	SETB CLK
	
	REPEAT:

	MOV A, 0x39
	LCALL GET_DOT_PATTERN
	CPL A
	MOV P0, A
	
	;---------- STAGE 1 END ----------
	
	SETB 0x20.0
	LJMP RETURN_FROM_DISPLAY_SUBR
	
	
	STAGE_2_DISPLAY:
	;----------- STAGE 2 -------------
	MOV P0, #0xFF; CLEAR THE PORT
	CLR CLK
	CLR DAT
	SETB CLK
	INC 0x39
	
	DJNZ 0x37, REPEAT
	INC R1
	CJNE R1, #0x34, CONT_CYCLE
	LJMP REPEAT_CYCLE
	
	CONT_CYCLE:
	MOV A, @R1
	MOV B, #8
	MUL AB
	MOV 0x39, A
	
	MOV 0x37, #8
	SJMP REPEAT
	;---------- STAGE 2 ENDS -------
	
	
	;----------------------------------------------
	
	RETURN_FROM_DISPLAY_SUBR:
	MOV 0x3C, 0x01; BACKUP R1 POINTER
	MOV 0x3D, 0x00; BACKUP R0 POINTER
	
	MOV A, 0x38; RESTORE A
	MOV B, 0x3B; RESTORE B
	MOV 0x01, 0x3E; RESTORE R1 POINTER
	MOV 0x00, 0x3F; RESTORE R0 POINTER
	
	MOV TL0, #0x00
	SETB TR0
	RETI

	
	

	
;REFERENCE: https://github.com/dhepper/font8x8/blob/master/font8x8_basic.h
;PATTERN SHOWN FROM LAST ROW TO FIRST ROW
;DATA SHOULD BE CPL BEFORE MOVING TO PORT
ORG 100H
	;DEFINE DOT MATRIX CHARACTER PATTERNS
	
;TO ACCESS THIS DATA, USE MOVC A, @A + PC
	GET_DOT_PATTERN:
	INC A; GET AROUND RET
	MOVC A, @A + PC
	RET
	
ORG 103H
	;----- FOR 0 -------
	DB 0x00
	DB 0x3E
	DB 0x67
	DB 0x6F
	DB 0x7B
	DB 0x73
	DB 0x63
	DB 0x3E
	
	;----- FOR 1 ------
	DB 0x00
	DB 0x3F
	DB 0x0C
	DB 0x0C
	DB 0x0C
	DB 0x0C
	DB 0x0E
	DB 0x0C

	;----- FOR 2 ------
	DB 0x00
	DB 0x3F
	DB 0x33
	DB 0x06
	DB 0x1C
	DB 0x30
	DB 0x33
	DB 0x1E
		
	; ----- FOR 3 ------
	DB 0x00
	DB 0x1E
	DB 0x33
	DB 0x30
	DB 0x1C
	DB 0x30
	DB 0x33
	DB 0x1E
	
	; ----- FOR 4 ------
	DB 0x00
	DB 0x78
	DB 0x30
	DB 0x7F
	DB 0x33
	DB 0x36
	DB 0x3C
	DB 0x38
	
	
	; ----- FOR 5 ------
	DB 0x00
	DB 0x1E
	DB 0x33
	DB 0x30
	DB 0x30
	DB 0x1F
	DB 0x03
	DB 0x3F
	
	; ----- FOR 6 ------
	DB 0x00
	DB 0x1E
	DB 0x33
	DB 0x33
	DB 0x1F
	DB 0x03
	DB 0x06
	DB 0x1C
	
	
	; ----- FOR 7 ------
	DB 0x00
	DB 0x0C
	DB 0x0C
	DB 0x0C
	DB 0x18
	DB 0x30
	DB 0x33
	DB 0x3F
	
	
	; ----- FOR 8 ------
	DB 0x00
	DB 0x1E
	DB 0x33
	DB 0x33
	DB 0x1E
	DB 0x33
	DB 0x33
	DB 0x1E
	
	
	; ----- FOR 9 ------
	DB 0x00
	DB 0x0E
	DB 0x18
	DB 0x30
	DB 0x3E
	DB 0x33
	DB 0x33
	DB 0x1E
	
	
	; ----- FOR A ------
	DB 0x00
	DB 0x33
	DB 0x33
	DB 0x3F
	DB 0x33
	DB 0x33
	DB 0x1E
	DB 0x0C
	
	
	; ----- FOR B ------
	DB 0x00
	DB 0x3F
	DB 0x66
	DB 0x66
	DB 0x3E
	DB 0x66
	DB 0x66
	DB 0x3F
	
	
	; ----- FOR C ------
	DB 0x00
	DB 0x3C
	DB 0x66
	DB 0x03
	DB 0x03
	DB 0x03
	DB 0x66
	DB 0x3C
	
	
	; ----- FOR D ------
	DB 0x00
	DB 0x1F
	DB 0x36
	DB 0x66
	DB 0x66
	DB 0x66
	DB 0x36
	DB 0x1F
	
	
	; ----- FOR E ------
	DB 0x00
	DB 0x7F
	DB 0x46
	DB 0x16
	DB 0x1E
	DB 0x16
	DB 0x46
	DB 0x7F
	
	
	; ----- FOR F ------
	DB 0x00
	DB 0x0F
	DB 0x06
	DB 0x16
	DB 0x1E
	DB 0x16
	DB 0x46
	DB 0x7F
		
	; ----- FOR DASH (10)-----
	DB 0x00
	DB 0x00
	DB 0x00
	DB 0x00
	DB 0x3C
	DB 0x00
	DB 0x00
	DB 0x00
		
	;------ FOR ? (11) --------
	DB 0x00
	DB 0x0C
	DB 0x00
	DB 0x0C
	DB 0x18
	DB 0x30
	DB 0x33
	DB 0x1E
		
	;------ FOR R (12) --------
	DB 0x00
	DB 0x67
	DB 0x66
	DB 0x36
	DB 0x6E
	DB 0x66
	DB 0x66
	DB 0x3F
	
	;------ FOR W (13) --------
	DB 0x00
	DB 0x63
	DB 0x77
	DB 0x7F
	DB 0x6B
	DB 0x63
	DB 0x63
	DB 0x63
		
	;------ BLANK (14) -------
	DB 0x00
	DB 0x00
	DB 0x00
	DB 0x00
	DB 0x00
	DB 0x00
	DB 0x00
	DB 0x00
		


;------------- MAIN PROGRAM STARTS HERE -------------		
ORG 250H
	START:

	
	;----------- CONFIGURE THE DIPLAY REG -------------
	;0x30 TO 0x33
	MOV 0x31, #0x14
	MOV 0x32, #0x14
	MOV 0x33, #0x14
	
	
	
	;	--------- DEFINE TIMER0 FOR DISPLAY UPDATE --------
	MOV TMOD, #0x12; TIMER 0 8 BIT AUTORELOAD, TIMER 1 IN 16 BIT MODE
	MOV TH0, #0x00
	MOV TL0, #0x00
	
	CLR 0x20.0
	SETB EA
	SETB ET0; TIMER 0 OVERFLOW INTERRUPT
	SETB TR0
	
	
	
	;------------ MONITOR THE MATRIX KEYBOARD ------------
	
	REPEAT_INF:
	;CHECK READ AND WRITE BUTTON
	JB RW_BTN, WRITE_OPER_BTN
	;READ OPERATION
	MOV 0x30, #0x12
	SJMP CONT_MONITOR_KEYB
	
	WRITE_OPER_BTN:
	MOV 0x30, #0x13
	
	CONT_MONITOR_KEYB:
	CLR 0x20.1; VALID BUTTON FLAG CLEARED
	LCALL MONITOR_KEYB
	JNB 0x20.1, REPEAT_INF
	
	;VALID BUTTON CLICK FOUND
	;PERFORM THE TASK
	;FIRST GET THE ADDRESS
	MOV 0x31, #0x10
	MOV 0x32, #0x10
	MOV 0x33, #0x10
	
	;---------------- GET ADDRESS ---------------------
	
	MOV R7, #0x03; INIT THE COUNTER
	
	REPEAT_GET_ADD_BTN:
	CLR 0x20.1; VALID BUTTON FLAG CLEARED
	LCALL MONITOR_KEYB
	JNB 0x20.1, REPEAT_GET_ADD_BTN
	
	;VALID BUTTON CLICK FOUND
	MOV 0x31, 0x32
	MOV 0x32, 0x33
	MOV 0x33, A
	
	DJNZ R7, REPEAT_GET_ADD_BTN
	
	;DONE GETTING THE ADDRESS
	
	; ========= 24C16B EEPROM OPERATIONS =============
	LCALL STARTC
	MOV A, #0xA0; ADDRESS WITH WRITE OPERATION
	ORL A, 0x31; MSB ADDRESS BITS
	LCALL SEND
	MOV A, 0x32
	SWAP A
	ORL A, 0x33
	LCALL SEND; SEND THE ADDRESS TO EEPROM
	
	MOV 0x31, #0x14; BLANK THE MSB DIGIT
	;--------------------------------------------------
	
	
	
	;------------ PERFORM OPERATION ----------------------
	;NOW CHECK WHICH ACTION TO PERFORM, READ OR WRITE
	MOV A, 0x30
	
	CJNE A, #0x12, WRITE_OPERATION_ROUTINE
	;PERFORM READ OPERATION ON THE ADDRESS
	;ADDRESS IS PRESENT IN REGISTERS 0x31 TO 0x33
	LCALL RSTART; RESTART CONDITION
	MOV A, #0xA1; ADDRESS WITH READ OPERATION
	LCALL SEND
	
	LCALL RECV
	LCALL NAK
	
	LCALL STOP
	
	MOV 0x33, A
	ANL 0x33, #0x0F

	SWAP A
	MOV 0x32, A
	ANL 0x32, #0x0F

	LJMP DONE_PERFORM_OPER
	
	WRITE_OPERATION_ROUTINE:
	;PERFORM WRITE OPERATION ON THE ADDRESS;
	;FIRST GET THE DATA THEN WRITE
	
	;SHOW DASHES ON DISPLAY
	MOV 0x32, #0x10
	MOV 0x33, #0x10
	
	
	MOV R7, #0x02; INIT A COUNTER
	REPEAT_GET_DATA_BTN:
	CLR 0x20.1; VALID BUTTON FLAG CLEARED
	LCALL MONITOR_KEYB
	JNB 0x20.1, REPEAT_GET_DATA_BTN
	
	MOV 0x32, 0x33
	MOV 0x33, A
	
	DJNZ R7, REPEAT_GET_DATA_BTN
	
	;WRITE THE DATA THEN DONE
	
	MOV A, 0x32
	SWAP A
	ORL A, 0x33
	LCALL SEND
	LCALL STOP
	
	;CLEAR THE DISPLAY
	MOV 0x32, #0x14
	MOV 0x33, #0x14
	
	;DONE PERFORMING OPERATION
	DONE_PERFORM_OPER:
	;-----------------------------------------------------
	CLR A
	LJMP REPEAT_INF
		
		
		

MONITOR_KEYB:
	;GET INFORMATION ABOUT WHICH BUTTON WAS CLICKED.
	;VALUE STORED IN ACC REGISTER
	
	MOV P1, #0x0F; CONFIGURE MATRIX KEYBOARD. COLUMNS -> 1, ROWS -> 0
	
	JB P1.0, CHK_NXT_MATR_PIN_C1
	;C0 IS 0
	;POSSIBLE BUTTONS: 1,4,7,0
	
			SETB P1.4
			JNB P1.0, CLR_NXT_ROW_C0_0
					;1 WAS CLICKED
					MOV A, #0x01
					
					CLR P1.4
					WAIT_FOR_REL_C0_R0:
					JNB P1.0, WAIT_FOR_REL_C0_R0
					
					LJMP DONE_C0
			
			CLR_NXT_ROW_C0_0:
			SETB P1.5
			JNB P1.0, CLR_NXT_ROW_C0_1
					;4 WAS CLICKED
					MOV A, #0x04
					
					CLR P1.5
					WAIT_FOR_REL_C0_R1:
					JNB P1.0, WAIT_FOR_REL_C0_R1
					
					
					LJMP DONE_C0

			CLR_NXT_ROW_C0_1:
			SETB P1.6
			JNB P1.0, CLR_NXT_ROW_C0_2
					;7 WAS CLICKED
					MOV A, #0x07
					
					CLR P1.6
					WAIT_FOR_REL_C0_R2:
					JNB P1.0, WAIT_FOR_REL_C0_R2
					
					LJMP DONE_C0
			
			CLR_NXT_ROW_C0_2:
					;0 WAS CLICKED
					MOV A, #0x00
					
					CLR P1.7
					WAIT_FOR_REL_C0_R3:
					JNB P1.0, WAIT_FOR_REL_C0_R3
					
					LJMP DONE_C0

			DONE_C0:
			
	LJMP GO_BACK_MATRIX
	
	CHK_NXT_MATR_PIN_C1:
	JB P1.1, CHK_NXT_MATR_PIN_C2
	;C1 IS 0
	;POBBIBLE BUTTONS: 2,5,8,D
	
			SETB P1.4
			JNB P1.1, CLR_NXT_ROW_C1_0
					;2 WAS CLICKED
					MOV A, #0x02
					
					CLR P1.4
					WAIT_FOR_REL_C1_R0:
					JNB P1.1, WAIT_FOR_REL_C1_R0
					
					LJMP DONE_C1
			
			CLR_NXT_ROW_C1_0:
			SETB P1.5
			JNB P1.1, CLR_NXT_ROW_C1_1
					;5 WAS CLICKED
					MOV A, #0x05
					
					CLR P1.5
					WAIT_FOR_REL_C1_R1:
					JNB P1.1, WAIT_FOR_REL_C1_R1
					
					
					LJMP DONE_C1

			CLR_NXT_ROW_C1_1:
			SETB P1.6
			JNB P1.1, CLR_NXT_ROW_C1_2
					;8 WAS CLICKED
					MOV A, #0x08
					
					CLR P1.6
					WAIT_FOR_REL_C1_R2:
					JNB P1.1, WAIT_FOR_REL_C1_R2
					
					LJMP DONE_C1
			
			CLR_NXT_ROW_C1_2:
					;D WAS CLICKED
					MOV A, #0x0D
					
					CLR P1.7
					WAIT_FOR_REL_C1_R3:
					JNB P1.1, WAIT_FOR_REL_C1_R3
					
					LJMP DONE_C1

			DONE_C1:

	LJMP GO_BACK_MATRIX

	CHK_NXT_MATR_PIN_C2:
	JB P1.2, CHK_NXT_MATR_PIN_C3
	;C2 IS 0
	;POSSIBLE BUTTONS: 3,6,9,E
	
			SETB P1.4
			JNB P1.2, CLR_NXT_ROW_C2_0
					;3 WAS CLICKED
					MOV A, #0x03
					
					CLR P1.4
					WAIT_FOR_REL_C2_R0:
					JNB P1.2, WAIT_FOR_REL_C2_R0
					
					LJMP DONE_C2
			
			CLR_NXT_ROW_C2_0:
			SETB P1.5
			JNB P1.2, CLR_NXT_ROW_C2_1
					;6 WAS CLICKED
					MOV A, #0x06
					
					CLR P1.5
					WAIT_FOR_REL_C2_R1:
					JNB P1.2, WAIT_FOR_REL_C2_R1
					
					
					LJMP DONE_C2

			CLR_NXT_ROW_C2_1:
			SETB P1.6
			JNB P1.2, CLR_NXT_ROW_C2_2
					;9 WAS CLICKED
					MOV A, #0x09
					
					CLR P1.6
					WAIT_FOR_REL_C2_R2:
					JNB P1.2, WAIT_FOR_REL_C2_R2
					
					LJMP DONE_C2
			
			CLR_NXT_ROW_C2_2:
					;E WAS CLICKED
					MOV A, #0x0E
					
					CLR P1.7
					WAIT_FOR_REL_C2_R3:
					JNB P1.2, WAIT_FOR_REL_C2_R3
					
					LJMP DONE_C2

			DONE_C2:
	
	LJMP GO_BACK_MATRIX
	
	CHK_NXT_MATR_PIN_C3:
	JB P1.3, NO_VALID_BTN_CLICK
	;C3 IS 0
	;POSSIBLE BUTTONS: A,B,C,F
	
			SETB P1.4
			JNB P1.3, CLR_NXT_ROW_C3_0
					;A WAS CLICKED
					MOV A, #0x0A
					
					CLR P1.4
					WAIT_FOR_REL_C3_R0:
					JNB P1.3, WAIT_FOR_REL_C3_R0
					
					LJMP DONE_C3
			
			CLR_NXT_ROW_C3_0:
			SETB P1.5
			JNB P1.3, CLR_NXT_ROW_C3_1
					;B WAS CLICKED
					MOV A, #0x0B
					
					CLR P1.5
					WAIT_FOR_REL_C3_R1:
					JNB P1.3, WAIT_FOR_REL_C3_R1
					
					
					LJMP DONE_C3

			CLR_NXT_ROW_C3_1:
			SETB P1.6
			JNB P1.3, CLR_NXT_ROW_C3_2
					;C WAS CLICKED
					MOV A, #0x0C
					
					CLR P1.6
					WAIT_FOR_REL_C3_R2:
					JNB P1.3, WAIT_FOR_REL_C3_R2
					
					LJMP DONE_C3
			
			CLR_NXT_ROW_C3_2:
					;F WAS CLICKED
					MOV A, #0x0F
					
					CLR P1.7
					WAIT_FOR_REL_C3_R3:
					JNB P1.3, WAIT_FOR_REL_C3_R3
					
					LJMP DONE_C3

			DONE_C3:
	
	LJMP GO_BACK_MATRIX
	
	NO_VALID_BTN_CLICK:
	RET
	
	GO_BACK_MATRIX:
	SETB 0x20.1; VALID BUTTON CLICK
	
	RET
	
	
;############### I2C Subroutines ###################

;****************************************
;RESTART CONDITION FOR I2C COMMUNICATION
;****************************************

RSTART:
	CLR SCL
	SETB SDA
	SETB SCL
	LCALL I2C_DELAY
	CLR SDA
	LCALL I2C_DELAY
	CLR SCL
	RET
 
 
;****************************************
;START CONDITION FOR I2C COMMUNICATION
;****************************************

STARTC:
	SETB SCL
	LCALL I2C_DELAY
	CLR SDA
	LCALL I2C_DELAY
	CLR SCL
	RET
 
 
;*****************************************
;STOP CONDITION FOR I2C BUS
;*****************************************

STOP:
	CLR SCL
	CLR SDA
	SETB SCL
	LCALL I2C_DELAY
	SETB SDA
	RET
 
 
;*****************************************
;SENDING DATA TO SLAVE ON I2C BUS
;*****************************************

SEND:
	MOV R4,#08
BACK:
	CLR SCL
	LCALL I2C_DELAY
	RLC A
	MOV SDA,C
	SETB SCL
	LCALL I2C_DELAY
	DJNZ R4,BACK
	CLR SCL
	SETB SDA
	SETB SCL
	MOV C, SDA
	CLR SCL
	
	RET
 
 
;*****************************************
;ACK AND NAK FOR I2C BUS
;*****************************************

ACK:
	CLR SDA
	SETB SCL
	CLR SCL
	SETB SDA
	RET
 
NAK:
	SETB SDA
	SETB SCL
	CLR SCL
	SETB SCL
	RET
 
 
;*****************************************
;RECEIVING DATA FROM SLAVE ON I2C BUS
;*****************************************

RECV:
	MOV R4,#08
BACK2:
	CLR SCL
	LCALL I2C_DELAY
	SETB SCL
	LCALL I2C_DELAY
	MOV C,SDA
	RLC A
	DJNZ R4,BACK2
	CLR SCL
	
	RET
	
;*****************************************
;I2C SETUP AND HOLD DELAY
;-----------------------------------------
;FOR 24CXXX MIN HOLD TIME AND SETUP TIME IS 5uS
I2C_DELAY:
	MOV R3, #0x05;
	I2C_D: DJNZ R3, I2C_D
	RET

		
END